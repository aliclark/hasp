<!DOCTYPE html>
<html>
  <head>
    <title>Hasp in a Lunch break</title>
    <link rel="stylesheet" type="text/css" href="style.css">
  </head>
  <body>
    <h1>Hasp in a Lunch break</h1>
    <div class="section" id="scheme">
      <h2>Download Scheme</h2>
      <p>
        Hasp is a Scheme program, so you'll need a Scheme interpreter.
        Hasp is known to work on both <a href="http://www.gnu.org/software/guile/guile.html">Guile</a> and
        <a href="http://dynamo.iro.umontreal.ca/~gambit/wiki/index.php/Main_Page">Gambit</a>,
        so if you already have a different Scheme, I'd suggest installing one of these
        for now and worry later about getting Hasp running on your other interpreter.
        Most distros have Guile packaged up for easy installation.
      </p>
    </div>
    <div class="section" id="haskell">
      <h2>Download Haskell</h2>
      <p>
        Hasp is known to work with the <a href="http://www.haskell.org/ghc/">GHCi</a> and <a href="http://www.haskell.org/hugs/">Hugs</a> interpreters,
        so its probably easiest to use one of those for now.
        Both of these are likely to be packaged by your distro.
      </p>
    </div>
    <div class="section" id="hasp">
      <h2>Download Hasp</h2>
      <p>
        If you have git, just run this command:
      </p>
      <pre>git clone git://github.com/aliclark/Hasp.git</pre>
      <p>
        Otherwise, download and unpack <a href="http://www-student.cs.york.ac.uk/~anc505/code/hasp/hasp.tar.gz">the tarball</a>.
      </p>
    </div>
    <div class="section" id="setup">
      <h2>Setup Hasp</h2>
      <p>
        When you download Hasp, it'll have whatever settings I've been using recently.
        To make sure it has the right settings for you, we run the <a href="hasp.html#install">install</a> script.
      </p>
<pre>
cd hasp
bin/<a href="hasp.html#install">install</a>
</pre>
        <p>
          Hasp will first ask which Haskell interpreter you are using.
        </p>
        <p>
          Next it will ask if you want indentation reading at the interpreter.
          Personally I don't use indentation at the interpreter,
          because I get tired of putting double newlines after each statement,
          so I'd suggest answering "no" to that setting for now.
        </p>
        <p>
          Finally, it will ask which Scheme interpreter you are using.
        </p>
      </p>
    </div>
    <div class="section" id="use">
      <h2>Using Hasp</h2>
      <p>
        Now we've got Hasp all set up, we can use it! Run the <a href="hasp.html#gasps">gasps</a> script:
      </p>
      <pre>bin/<a href="hasp.html#gasps">gasps</a></pre>
      <p>
        You'll notice that it prints the same welcome message as your Haskell interpreter,
        and then loads a Haskell module called Hasp,
        which contains some basic <a href="hasp.html#haskell">Haspy Haskell things</a>.
      </p>
      <p>This is slightly different from your normal Haskell interpreter though - it takes Hasp as input.</p>
      <p>Let's plunge into our hello world:</p>
<pre>
Hasp> (<a href="hasp.html#def">def</a> printHi (putStrLn "Hello, world!"))
()
Hasp> printHi  
Hello, world!

Hasp> 
</pre>
      <p>
        This code looks very similar to the equivalent Haskell.
        One cool thing to note here that is that you can type <a href="hasp.html#def">def</a>
        forms into the prompt and they will be available later on when you type an expression.
      </p>
      <p>
        Just about every Hasp <a href="hasp.html#statements">statement</a>
        can be entered into the top level of <code>gasps</code>.
        <code>def</code> forms and <a href="hasp.html#signature">type signatures</a>
        will be implicitly wrapped around any expressions entered, with a <a href="hasp.html#let">let</a> form.
      </p>
      <p>
        The other statements entered will be grouped into a file called <code>hasp-repl.hasp</code> in the current directory and then loaded
        into the interpreter.
      </p>
      <h3>Using hooks</h3>
      <p>
        The normal interpreter hooks can also be used via Hasp. For example, typing <code>(:?)</code> will display the help text of the interpreter.
        Hasp provides a few additional <a href="hasp.html#hooks">hooks</a>
        called <a href="hasp.html#hload">hload</a>, <a href="hasp.html#scm">scm</a> and <a href="hasp.html#hs">hs</a>.
      </p>
      <p>
        <code>hload</code> can be used for interactively loading Hasp files, eg.
      </p>
      <pre>(:hload "mycode.hasp")</pre>
      <p>
        In doing this, Hasp will generate a file called <code>mycode.hs</code> as a side-effect, before loading it into the interpreter.
      </p>
      <p>
        Using <code>hs</code> allows any text to be passed through Hasp unaffected, eg.
      </p>
<pre>
Hasp> (>>= getLine putStrLn)   
(:hs "This is the input")
This is the input

Hasp> 
</pre>
      <p>
        Here it was necessary to delimit the input with <code>(:hs "...")</code>
        because otherwise it would be interpreted as Hasp code.
      </p>
      <h3>Settling in</h3>
      <p>
        Now that we've got a neat interactive REPL up and running,
        we can think about moving Hasp to a more permanent directory
        and setting up a simple script so we can just type <code>gasps</code>
        into our prompt from any directory, rather than always typing the absolute path.
      </p>
      <p>
        Personally, I've got Hasp in the directory <code>/home/ali/code/hasp</code>,
        but a more suitable place for you might be <code>/usr/local/src/hasp</code>.
      </p>
      <p>Anyway, here is a small script I've got at <code>/usr/local/bin/gasps</code> for just that:</p>
<pre>
#!/bin/bash

$(dirname "$0")/../../../home/ali/code/hasp/bin/gasps
</pre>
      <p>If you have Hasp at <code>/usr/local/src/hasp</code>, you may want to use this instead:</p>
<pre>
#!/bin/bash

$(dirname "$0")/../src/hasp/bin/gasps
</pre>
      <p>A simple symlink doesn't work because Hasp works relative from the directory it is being called from.</p>
      <h3>Compiling Hasp code</h3>
      <p>
        So far we've seen one way to turn Hasp code into Haskell,
        by making a hasp file and loading it into the interpreter using <code>hload</code>,
        which will secondarily create a Haskell file.
      </p>
      <p>
        Hasp also provides a script called <a href="hasp.html#fasps">fasps</a>
        for compiling Hasp code at the command line. The interface is incredibly simple:
        <code>fasps</code> reads Hasp code from its standard input, and prints Haskell to its standard output.
      </p>
      <p>With this in mind, we can use redirection to compile one file into another:
      <pre>bin/<a href="hasp.html#fasps">fasps</a> &lt; mycode.hasp > mycode.hs</pre>
    </div>
    <div class="section" id="macros">
      <h2>Macros</h2>
      <p>
        One day you might notice that there is a general pattern to some of the code you are writing.
        On most days, you will recognise a good higher order abstraction or use of monads to abstract away the general pattern.
        Every so often however, the repetition cannot be abstracted using lambdas and monads, and this is where macros come in.
      </p>
      <p>
        The secret to understanding macros is to remember that every macro has an exactly equivalent code that it transforms into
        (the generated code will often be a lot longer and less abstract).
      </p>
      <p>
        Well anyway, thats enough power-tripping for now, lets get a move on and define a few of our own :)
      </p>
      <p>
        The Hasp compiler is written in Scheme, which makes it convenient and easy to use Scheme to define Hasp macros.
        In Hasp's <code>src</code> directory are two files, <code>std-macros.scm</code> and <code>usr-macros.scm</code>.
        The std-macros file contains definitions for the standard Hasp macros.
        The usr-macros file is pretty much empty and this is where you can define your Scheme macro code.
        The std-macros file isn't any more privileged than the usr-macros file -
        you could just as easily swap their filenames and they will still work the same,
        but it is useful to keep the distinction so I can easily update the std-macros file without overwriting your macros.
      </p>
      <h3>A gentle example</h3>
      <p>
        With that in mind, I'll go ahead and dissect a macro from <code>std-macros.scm</code>,
        explaining the rationale for why I wrote it and then showing how I implemented it. Lets look at <code>defn</code>.
      </p>
      <p>
        I noticed quite early on that a standard way to define a function in Haskell was to start with a type signature,
        then possibly a base-case pattern definition for the function, and then one or two more pattern definitions.
        All in all we've repeated the name twice and a small amount of boilerplate for each function definition.
        Since I don't like repeating myself, I made a <code>defn</code> macro, based on the <code>defn</code> form of Clojure.
      </p>
      <p>
        The first step to writing the macro is getting hold of the code we want to generate:
      </p>
<pre>
;; This code might look a little weird -
;; unlike Haskell, in Hasp all our code is in lambda expressions, not pattern definitions.
;; It is partly thanks to defn that we can do this while retaining sanity.

(:: myfunc typex)
(def (myfunc vars...)
  (case-of (tup vars...)
    ((tup pattern...) definition...)
    ((tup pattern...) definition...)))
</pre>
      <p>And the code we actually want to write:</p>
<pre>
(defn myfunc typex
  ((pattern... ) definition...)
  ((pattern... ) definition...))
</pre>
      <p>
        So we know that our macro takes the form of
        <code>(defn name typex . definitions)</code>.
        Indeed, if you look at the docs for <a href="hasp.html#defn">defn</a>
        you'll see that this is the case.
      </p>
      <p>
        You may also have noticed that <code>vars...</code> does not appear in the code we want to write.
        That's okay, we'll use the <code>gens</code> function to generate them.
      </p>
      <p>
        So far, so good. Lets continue with the definition.
        We know we are generating multiple statements, so we group them with a <code>begin</code> statement:
      </p>
<pre>
(defmac (defn name typex . definitions)
  `(begin
    (:: ,name ,typex)
    (def (,name ,@vars) (case-of (tup ,@vars) ,@somethingHere))))
</pre>
      <p>
        The backquote says we are returning code, the comma tells Scheme to splice in a single expression,
        and the comma-at tells Scheme to splice in the elements of a list.
        There's still a lot to do here, we need work out the value of <code>vars</code> and <code>somethingHere</code>.
        Let's start with the <code>vars</code>.
      </p>
<pre>
(defmac (defn name typex . definitions)
  (let ((vars (map (lambda (x) (gens 'v)) (caar definitions))))
    `(begin
      (:: ,name ,typex)
      (def (,name ,@vars) (case-of (tup ,@vars) ,@somethingHere)))))
</pre>
      <p>
        Here we map through each of the arguments in the first <code>(pattern...)</code> list and generate a fresh symbol with <code>gens</code>.
      </p>
      <p>
        Now we need to work out the value of <code>somethingHere</code>.
        For this, we <code>map</code> across each of the definitions.
        We use the following Scheme lambda for the map:
      </p>
      <pre>(lambda (definition) (cons (cons 'tup (car definition)) (cdr definition)))</pre>
      <p>
        Here, <code>(car definition)</code> is the pattern list, <code>(pattern... )</code>
        which we add the <code>tup</code> name in front of, and the <code>(cdr definition)</code>
        is the definition part, <code>(definition ...)</code> which is spliced into the <code>case</code> form.
      </p>
<pre>
(defmac (defn name typex . definitions)
  (let ((vars (map (lambda (x) (gens 'v)) (caar definitions))))
    `(begin
      (:: ,name ,typex)
      (def (,name ,@vars)
        (case-of (tup ,@vars)
          ,@(map
            (lambda (definition)
              (cons (cons 'tup (car definition)) (cdr definition)))
            definitions))))))
</pre>
      <p>
        Lastly, for the sake of it, we allow the user to supply an empty list <code>()</code>
        for the typex if they just want to have definitions and no signature (tsk tsk).
      </p>
<pre>
(defmac (defn name typex . definitions)
  (let ((vars (map (lambda (x) (gens 'v)) (caar definitions))))
    `(begin
      ,(if (null? typex) '(begin) `(:: ,name ,typex))
      (def (,name ,@vars)
        (case-of (tup ,@vars)
          ,@(map
            (lambda (definition)
              (cons (cons 'tup (car definition)) (cdr definition)))
            definitions))))))
</pre>
      <p>An empty begin, <code>(begin)</code> just acts as a kind of noop and doesn't output any code.</p>
      <h3>Further macro tools</h3>
      <p>
        Throughout your macro definitions, you are free to use Scheme procedures to generate bits of code.
        Indeed, macros are first-class, so
      </p>
      <pre>(defmac (foo a) `(list ,a))</pre>
      <p>is exactly equivalent to</p>
      <pre>(defmac foo (lambda (a) `(list ,a)))</pre>
      <p>This allows you to do all sorts of lambda goodness like currying of macro functions.</p>
      <p>
        Additionally, Hasp provides functions to generate random symbol and type names, <code>gens</code> and <code>gent</code>,
        respectively. The only difference is that the symbol generated by <code>gent</code> starts with an Uppercase character.
      </p>
      <p>
        Finally, there is <code>macroexpand</code>, which takes Hasp code as input and returns the code,
        where if the form was a macro call, the returned code will be its macro-expansion.
      </p>
    </div>
    <div class="section" id="next">
      <h2>Where now?</h2>
      <p>You can use any of these links for a quick escape route on whatever remains of your lunch break :)</p>
      <ul>
        <li><a href="http://www.reddit.com/r/programming/">Proggit</a></li>
        <li><a href="http://news.ycombinator.com/">Hacker News</a></li>
        <li><a href="http://lambda-the-ultimate.org/">Lambda the Ultimate</a></li>
      </ul>
      <p>Please send <a href="mailto:anc505@york.ac.uk">feedback</a> on anything that needs improving!</p>
    </div>
  </body>
</html>
